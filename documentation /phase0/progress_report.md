# Uni Life Tracker 
## Summary of Specification 
Uni Life Tracker is an organizational platform in the form of an Android app that allows university students to coordinate their everyday routine. Users can track aspects of their school and personal life by creating/editing/deleting events such as school-related events (entity), including assessments, due dates, class times, and study sessions and then adding them to their calendar. The user will receive reminders in the form of push notifications if they choose to do so. Upon app launch, users see the today view, which covers all current responsibilities and events in a form of a to-do list, allowing users to check off completed tasks. The expense feature will allow users to budget their monthly expenses by updating and inputting their monthly expenditures. This landing page also features a menu that allows the user to view one of the three categories (mentioned above) to alter/view events.

## Summary of CRC Model
Currently, we have 17 CRC cards, with 3 entities, 3 use cases, 2 controllers, 1 presenter, and 9 subclasses. Our 3 entities are the Entities.Event, Entities.Expenses, and Entities.User, all of which have one corresponding use case, the UseCases.EventManager, ExpensesManger, and the UseCases.UserManager. The event entity has 9 subclasses, with each subclass representing one type of event. We decided to choose this design over implementing an instance variable "type" to differentiate between different events because each type of event only has very few unique properties. Implementing it into one class would make the class too big and labour intensive to differentiate between each event when we need to check or print something based on a certain property. Instead, we can simply check for the object's subclass to determine instantly which type of event it is. The entity Expense is implemented as a concrete class because there is no need at the moment for other classes to extend it. The Entities.User entity is also implemented as a concrete class for the same reason. 

The controller, SystemInOut is designed to only take in user information and make the decision to call the appropriate methods. It will also check the user's input to make sure it adheres to the basic data type rules. Our other controller, UniLifeTracker, has the main method of our program.

## Summary of Scenario Walk-Through 
Upon entering the program, the user sees on display a greeting. Afterwards, the user is prompted to enter some academic information about them, such as their name, the school they attend, and the courses they are enrolled in. Next, the user is prompted to add an event or exit the program. If the user selects to add an event, they are then prompted to choose which type of event or to return to the main menu. In this scenario, the user enters a deadline event, so they select that and are then prompted for the event details, such as name, end date, priority, and which course it's for. Once completed, the list of current events the user has is displayed, and they are once again asked if they want to add an event or exit the program. Once they select to exit, the program ends.

## Summary of Skeleton Program
While our skeleton program does not encompass all the elements specified in our specification and CRC model, we implemented only what is necessary for our scenario walk-through to run. This includes the Entities.Event entity class, the Entities.Deadline entity class (a subclass of Entities.Event), the UseCases.UserManager use case, and the command-line interface. 

## Open Questions 
+ What is the inheritance hierarchy for the Entities.Event entity?
+ How many test cases are needed, is there a limit, and are tests for getters/setters redundant?
+ What types of test cases would best showcase the effectiveness of our program?
+ For phase 0, we were able to have the controller and presenter in the same class, but for phase 1 and 2, how do we separate the two?

## Our Design
So far, the creation of Entities.Event as a parent class has allowed us to create subclasses using inheritance for each separate event type that has different parameters than a generic event. These instances would be stored in an ArrayList under a Entities.User instance, which allows all event instances for a user to be accessible in the collection. Since the main focus of our app is to help the user track all their events and deadlines, having the Entities.Event class be a superclass with the main characteristics of all the types of events we want to implement, such as social events, study sessions, assessments, deadlines, etc. makes our overall design simpler and easier to implement. 

We accomplished this while keeping in mind all the principles of SOLID. First of all, we made sure each class had one responsibility by dividing up the responsibilities for each class. We then made sure that each class is open for extension and closed for modification. For instance, suppose we intend to add a new type of Entities.Event, since we used inheritance as a way to create different types of events, there would be no need to modify any of the Entities.Event classes where we can just extend the Entities.Event class. Next, we made sure to incorporate the Liskov Substitution principle. This was done by having each of the Entities.Event subclasses able to be substituted for an Entities.Event class. Although we currently have no plans to use interfaces in our design, if we choose to do so, we would avoid violating the Interface Segregation principle by creating specialized interfaces. Since we applied both the Open/Closed and Liskov Substitution principles, this meant that we did not violate the last principle: the Dependency Inversion principle. 

## Group Progress Summary and Future Plans 
Overall, every member in our group contributed to the selection of the domain and assisted in the writing of the specification. The brainstorm for the CRC cards as well as the scenario walkthrough was completed by everyone within our daily group meetings. All classes within our skeleton program, with the exception of Entities.Event and UseCases.EventManager which were completed together, were divided among all our members. Some of the classes that were created were not fully implemented for phase 0, so they were commented out. Those classes will be used in phase 1 and onwards. 

Evgenia was responsible for implementing the Entities.Expenses class and started working on UseCases.ExpensesManager to be later used in phase 1 when the budget feature is implemented. She also created elements of the progress report such as the specification summary, contributed to the group progress and design explanation, added to the original specification and added questions to the open question section under the progress report. In the near future, she will be creating test cases for both cases she created and building onto the skeleton program as needed. 

Kathy implemented the Entities.User class and assisted with the implementation of the UseCases.UserManager class. She also completed the final design of the CRC model. As well, Kathy contributed to the progress report with the skeleton program, design, and group progress summary. For the upcoming phases, she plans to build on the Entities.User and UseCases.UserManager class, and improve the Entities.Event subclasses. 

Bolade implemented the Entities.Deadline class, the UniLifeTracker class and part of the UseCases.UserManager class. She also worked on the Entities.Assessment class which was not fully implemented for this phase. For the progress report, she wrote the summary of the scenario walkthrough, added a question to Open Questions, and contributed to the design and the group progress summary. The next thing Bolade plans to work on is to continue to improve and add to the Entities.Deadline, UniLifeTracker class, Entities.Assessment class, and parts of the UseCases.UserManager.

Sari implemented the Entities.Class and Entities.Work classes which he hopes to complete in the future phases. He also wrote all test cases in java.com.generic.ult.DeadlineTest, assisted in the final design, added questions for the Open Questions portion of the progress report and commented on how the SOLID principles were incorporated in the progress report. For the next phases, he will build on and improve the classes he was previously assigned and add test cases for each of the assigned event types.

Tong (Daniel) implemented the Entities.Social class (will be used in Phase 1), SystemInOut controller and condensed the UniLifeTracker class to its final form. Currently, the SystemInOut still has some minor drawbacks as it currently only catches errors partially, so Daniel hopes he will finish improving this class in phase 1. Additionally, SystemInOut's implementation relies too much on manually matching the user's request and the corresponding actions, so he hopes to think of a better way to process user input. Daniel also wrote the summary of CRC model in our progress report and helped set up ClickUp, a workspace to help us stay organized.

Dana implemented the Study Session class which will be used later in Phase 1 as one of the subclasses of Entities.Event. She also assisted with the implementation of the UseCases.UserManager class.  In terms of the CRC model, Dana helped come up with some of the subclasses for the main entity class Entities.Event, which included Entities.Social and Study Session. She also helped brainstorm ideas that could be implemented as part of Phase 1, which involved creating a login-in system as well as storing the user's data in a database.
